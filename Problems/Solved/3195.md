## Intuition

We want the smallest rectangle that covers **all the `1`s** in the
grid.\
The rectangle must have sides parallel to the grid, so its edges are
simply the **minimum and maximum row/column indices** where `1` appears.

Once we know the **top-most, bottom-most, left-most, and right-most**
positions containing `1`, the rectangle area is straightforward:

```js
area = (bottom - top + 1) * (right - left + 1)
```
Why `+1`?
Array indices are 0-based, so we need to add 1 to get the correct length.

## Approach

1.  Initialize boundaries:
    -   `top = h` (the lowest possible row index initially)
    -   `bottom = 0`
    -   `left = d` (the rightmost column initially)
    -   `right = 0`
2.  Traverse every cell in the grid:
    -   If `grid[i][j] == 1`:
        -   Update `top = min(top, i)`
        -   Update `bottom = max(bottom, i)`
        -   Update `left = min(left, j)`
        -   Update `right = max(right, j)`
3.  After scanning the whole grid, compute the rectangle area:
    ```js
    area = (bottom - top + 1) * (right - left + 1)
    ```

## Complexity

-   **Time Complexity:**\
    We visit each cell once → **O(h × d)**, where `h` is number of rows
    and `d` is number of columns.
-   **Space Complexity:**\
    Only a few variables for boundaries → **O(1)**.
# Code

```typescript []
function minimumArea(grid: number[][]): number {
    const h = grid.length;
    const d = grid[0].length;

    let top = h,
        bottom = 0,
        left = d,
        right = 0;

    for (let i = 0; i < h; i++) {
        for (let j = 0; j < d; j++) {
            if (grid[i][j] === 1) {
                if (i < top) top = i;
                if (i > bottom) bottom = i;
                if (j < left) left = j;
                if (j > right) right = j;
            }
        }
    }

    return (bottom - top + 1) * (right - left + 1);
}
```